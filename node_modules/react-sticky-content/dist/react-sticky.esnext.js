import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React from 'react';
import ResizeObserver from 'resize-observer-polyfill';

var getScrollParent = function getScrollParent(node) {
  var offsetParent = node;
  while (offsetParent = offsetParent.offsetParent) {
    var overflowYVal = getComputedStyle(offsetParent, null).getPropertyValue("overflow-y");
    if (overflowYVal === "auto" || overflowYVal === "scroll") return offsetParent;
  }
  return window;
};

var offsetTill = function offsetTill(node, target) {
  var current = node;
  var offset = 0;
  do {
    offset += current.offsetTop;
    current = current.offsetParent;
  } while (current && current !== target);
  return offset;
};

var stickyProp = null;
if (typeof CSS !== "undefined" && CSS.supports) {
  if (CSS.supports("position", "sticky")) stickyProp = "sticky";else if (CSS.supports("position", "-webkit-sticky")) stickyProp = "-webkit-sticky";
}

var StickyBox = function (_React$Component) {
  _inherits(StickyBox, _React$Component);

  function StickyBox() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, StickyBox);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = StickyBox.__proto__ || Object.getPrototypeOf(StickyBox)).call.apply(_ref, [this].concat(args))), _this), _this.registerContainerRef = function (n) {
      if (!stickyProp) return;
      _this.node = n;
      if (n) {
        _this.scrollPane = getScrollParent(_this.node);
        _this.latestScrollY = _this.scrollPane === window ? window.scrollY : _this.scrollPane.scrollTop;
        _this.scrollPane.addEventListener("scroll", _this.handleScroll);
        _this.scrollPane.addEventListener("mousewheel", _this.handleScroll);
        if (_this.scrollPane === window) {
          window.addEventListener("resize", _this.updateViewport);
          _this.updateViewport();
        } else {
          _this.rosp = new ResizeObserver(_this.updateScrollPane);
          _this.rosp.observe(_this.scrollPane);
          _this.updateScrollPane();
        }
        _this.ropn = new ResizeObserver(_this.updateParentNode);
        _this.ropn.observe(_this.node.parentNode);
        _this.updateParentNode();

        _this.ron = new ResizeObserver(_this.updateNode);
        _this.ron.observe(_this.node);
        _this.updateNode();

        _this.initial();
      } else {
        _this.scrollPane.removeEventListener("mousewheel", _this.handleScroll);
        _this.scrollPane.removeEventListener("scroll", _this.handleScroll);
        if (_this.scrollPane === window) {
          window.removeEventListener("resize", _this.getMeasurements);
        } else {
          _this.rosp.disconnect();
        }
        _this.ropn.disconnect();
        _this.ron.disconnect();
        _this.scrollPane = null;
      }
    }, _this.updateViewport = function () {
      _this.viewPortHeight = window.innerHeight;
      _this.scrollPaneOffset = 0;
    }, _this.updateScrollPane = function () {
      _this.viewPortHeight = _this.scrollPane.offsetHeight;
      _this.scrollPaneOffset = _this.scrollPane.getBoundingClientRect().top;
    }, _this.updateParentNode = function () {
      var parentNode = _this.node.parentNode;
      var computedParentStyle = getComputedStyle(parentNode, null);
      var parentPaddingTop = parseInt(computedParentStyle.getPropertyValue("padding-top"), 10);
      var parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue("padding-bottom"), 10);
      var verticalParentPadding = parentPaddingTop + parentPaddingBottom;
      _this.naturalTop = offsetTill(parentNode, _this.scrollPane) + parentPaddingTop + _this.scrollPaneOffset;
      _this.parentHeight = parentNode.getBoundingClientRect().height - verticalParentPadding;
    }, _this.updateNode = function () {
      _this.nodeHeight = _this.node.getBoundingClientRect().height;
    }, _this.handleScroll = function () {
      var scrollY = _this.scrollPane === window ? window.scrollY : _this.scrollPane.scrollTop;
      if (scrollY === _this.latestScrollY) return;
      if (_this.nodeHeight <= _this.viewPortHeight) {
        // Just make it sticky if node smaller than viewport
        _this.initial();
        return;
      }
      var scrollDelta = scrollY - _this.latestScrollY;
      if (scrollDelta > 0) {
        // scroll down
        if (_this.mode === "stickyTop") {
          if (scrollY + _this.scrollPaneOffset > _this.naturalTop) {
            _this.mode = "relative";
            _this.node.style.position = "relative";
            _this.offset = Math.max(0, _this.scrollPaneOffset + _this.latestScrollY - _this.naturalTop);
            _this.node.style.top = _this.offset + "px";
          }
        } else if (_this.mode === "relative") {
          if (scrollY + _this.scrollPaneOffset + _this.viewPortHeight > _this.naturalTop + _this.nodeHeight + _this.offset) {
            _this.mode = "stickyBottom";
            _this.node.style.position = stickyProp;
            _this.node.style.top = _this.viewPortHeight - _this.nodeHeight + "px";
          }
        }
      } else {
        // scroll up
        if (_this.mode === "stickyBottom") {
          if (_this.scrollPaneOffset + scrollY + _this.viewPortHeight < _this.naturalTop + _this.parentHeight) {
            _this.mode = "relative";
            _this.node.style.position = "relative";
            _this.offset = _this.scrollPaneOffset + _this.latestScrollY + _this.viewPortHeight - (_this.naturalTop + _this.nodeHeight);
            _this.node.style.top = _this.offset + "px";
          }
        } else if (_this.mode === "relative") {
          if (_this.scrollPaneOffset + scrollY < _this.naturalTop + _this.offset) {
            _this.mode = "stickyTop";
            _this.node.style.position = stickyProp;
            _this.node.style.top = 0;
          }
        }
      }

      _this.latestScrollY = scrollY;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(StickyBox, [{
    key: "initial",
    value: function initial() {
      var _props = this.props,
          bottom = _props.bottom,
          style = _props.style;

      if (bottom) {
        if (this.mode !== "stickyBottom") {
          this.mode = "stickyBottom";
          this.node.style.position = stickyProp;
          this.node.style.top = this.viewPortHeight - this.nodeHeight + "px";
        }
      } else {
        if (this.mode !== "stickyTop") {
          this.mode = "stickyTop";
          //if top is passed in component, it will apply else it will work as before.
          this.node.style.top = !style ? 0 : style.top;
          this.node.style.top = 0;
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _props2 = this.props,
          children = _props2.children,
          className = _props2.className,
          style = _props2.style;

      return React.createElement(
        "div",
        { className: className, style: style, ref: this.registerContainerRef },
        children
      );
    }
  }]);

  return StickyBox;
}(React.Component);

export default StickyBox;
